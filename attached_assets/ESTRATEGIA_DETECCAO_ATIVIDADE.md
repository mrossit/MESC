# ESTRAT√âGIA DE DETEC√á√ÉO DE ATIVIDADE INTELIGENTE
**Sistema:** MESC v5.3.0
**Timeout Base:** 10 minutos
**Compatibilidade:** Android 5.0+, iOS 11+, Desktop

---

## üéØ OBJETIVOS

1. ‚úÖ Detectar atividade real do usu√°rio
2. ‚úÖ N√£o deslogar usu√°rios em uso leg√≠timo (leitura, background)
3. ‚úÖ Funcionar em dispositivos m√≥veis antigos
4. ‚úÖ Sincronizar entre m√∫ltiplas abas
5. ‚úÖ Respeitar limita√ß√µes do PWA

---

## üì± TIPOS DE ATIVIDADE CONSIDERADOS

### ‚úÖ Atividade ATIVA (Reseta Timer)

| Tipo | Evento | Peso | Justificativa |
|------|--------|------|---------------|
| **Intera√ß√£o Direta** | click, touch, tap | 100% | Usu√°rio claramente ativo |
| **Navega√ß√£o** | mudan√ßa de rota/p√°gina | 100% | Usu√°rio navegando no app |
| **Formul√°rio** | input, textarea, select | 100% | Preenchendo dados |
| **Scroll Intencional** | scroll (com delta > 50px) | 80% | Lendo conte√∫do ativamente |
| **Teclado** | keypress, keydown | 100% | Digitando |
| **Requisi√ß√£o API** | fetch/ajax bem-sucedido | 90% | App em uso ativo |

### ‚ö†Ô∏è Atividade PASSIVA (N√ÉO Reseta Timer, mas Pausa)

| Tipo | Evento | A√ß√£o | Justificativa |
|------|--------|------|---------------|
| **App em Background** | visibilitychange (hidden) | Pausa contagem | Pode voltar a qualquer momento |
| **Leitura de Conte√∫do** | p√°gina est√°tica aberta | Timer estendido (20min) | Uso leg√≠timo |
| **Download/Export** | gerando PDF/Excel | Pausa contagem | Opera√ß√£o em andamento |

### ‚ùå Inatividade REAL (Conta Timer)

| Tipo | Situa√ß√£o | Timeout |
|------|----------|---------|
| **Abandono** | Nenhum evento por 10min | 10min ‚Üí Logout |
| **Navegador Fechado** | beforeunload | Imediato (marca sess√£o) |
| **Aba Inativa** | visibilitychange (hidden) por >20min | 20min ‚Üí Logout |

---

## üîß IMPLEMENTA√á√ÉO T√âCNICA

### 1. Sistema de Estados de Sess√£o

```typescript
// client/src/lib/sessionState.ts (NOVO ARQUIVO)

export enum SessionState {
  ACTIVE = 'active',           // Uso ativo recente (<2min)
  IDLE = 'idle',               // Sem intera√ß√£o mas vis√≠vel (2-10min)
  BACKGROUND = 'background',   // App em background
  READING = 'reading',         // Modo leitura (conte√∫do est√°tico)
  PROCESSING = 'processing',   // Processando opera√ß√£o longa
  EXPIRED = 'expired'          // Sess√£o expirada (>10min idle)
}

export interface SessionContext {
  state: SessionState;
  lastActivityAt: number;
  lastInteractionAt: number;
  isVisible: boolean;
  isOnline: boolean;
  currentRoute: string;
  idleMinutes: number;
  hasActiveOperation: boolean; // Upload, download, etc
}

class SessionManager {
  private context: SessionContext;
  private listeners: Set<(ctx: SessionContext) => void>;

  constructor() {
    this.context = {
      state: SessionState.ACTIVE,
      lastActivityAt: Date.now(),
      lastInteractionAt: Date.now(),
      isVisible: !document.hidden,
      isOnline: navigator.onLine,
      currentRoute: window.location.pathname,
      idleMinutes: 0,
      hasActiveOperation: false
    };
    this.listeners = new Set();
    this.setupListeners();
  }

  private setupListeners() {
    // Visibilidade da p√°gina
    document.addEventListener('visibilitychange', () => {
      this.context.isVisible = !document.hidden;

      if (document.hidden) {
        console.log('[SESSION] üì± App foi para background');
        this.setState(SessionState.BACKGROUND);
      } else {
        console.log('[SESSION] üì± App voltou para foreground');
        // Verifica quanto tempo ficou em background
        const minutesInBackground = Math.floor(
          (Date.now() - this.context.lastActivityAt) / 60000
        );

        if (minutesInBackground > 20) {
          console.log(`[SESSION] ‚ö†Ô∏è ${minutesInBackground}min em background - verificando sess√£o`);
          this.checkServerSession();
        } else {
          this.setState(SessionState.ACTIVE);
          this.recordActivity();
        }
      }
    });

    // Status de conex√£o
    window.addEventListener('online', () => {
      this.context.isOnline = true;
      console.log('[SESSION] üåê Conex√£o restaurada');
      this.checkServerSession();
    });

    window.addEventListener('offline', () => {
      this.context.isOnline = false;
      console.log('[SESSION] üì° Sem conex√£o - pausando verifica√ß√µes');
    });

    // Navega√ß√£o (mudan√ßa de rota)
    window.addEventListener('popstate', () => {
      this.recordActivity();
      this.context.currentRoute = window.location.pathname;
    });
  }

  recordActivity() {
    this.context.lastActivityAt = Date.now();
    this.context.lastInteractionAt = Date.now();
    this.context.idleMinutes = 0;

    if (this.context.state !== SessionState.PROCESSING) {
      this.setState(SessionState.ACTIVE);
    }

    this.notifyListeners();
  }

  recordInteraction(type: string) {
    console.log(`[SESSION] üëÜ Intera√ß√£o: ${type}`);
    this.recordActivity();
  }

  setState(state: SessionState) {
    if (this.context.state !== state) {
      console.log(`[SESSION] Estado: ${this.context.state} ‚Üí ${state}`);
      this.context.state = state;
      this.notifyListeners();
    }
  }

  setActiveOperation(active: boolean) {
    this.context.hasActiveOperation = active;
    if (active) {
      this.setState(SessionState.PROCESSING);
    }
  }

  getContext(): Readonly<SessionContext> {
    return { ...this.context };
  }

  async checkServerSession() {
    // Implementa√ß√£o no pr√≥ximo bloco
  }

  subscribe(listener: (ctx: SessionContext) => void) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  private notifyListeners() {
    this.listeners.forEach(fn => fn(this.getContext()));
  }
}

export const sessionManager = new SessionManager();
```

### 2. Hook Atualizado com Intelig√™ncia de Contexto

```typescript
// client/src/hooks/useActivityMonitor.tsx (ATUALIZADO)

import { useEffect, useRef, useCallback } from 'react';
import { useLocation } from 'wouter';
import { useToast } from '@/hooks/use-toast';
import { sessionManager, SessionState } from '@/lib/sessionState';

const IDLE_TIMEOUT = 10 * 60 * 1000;      // 10min sem intera√ß√£o
const BACKGROUND_TIMEOUT = 20 * 60 * 1000; // 20min em background
const CHECK_INTERVAL = 30 * 1000;          // Verifica a cada 30s
const READING_ROUTES = ['/schedules', '/formation', '/reports']; // Rotas de leitura

export function useActivityMonitor() {
  const [location, setLocation] = useLocation();
  const { toast } = useToast();
  const timeoutRef = useRef<NodeJS.Timeout>();
  const checkIntervalRef = useRef<NodeJS.Timeout>();

  const isReadingMode = useCallback(() => {
    return READING_ROUTES.some(route => location.startsWith(route));
  }, [location]);

  const getTimeoutDuration = useCallback(() => {
    const ctx = sessionManager.getContext();

    // Se est√° processando algo, n√£o expira
    if (ctx.hasActiveOperation) {
      return null; // Sem timeout
    }

    // Se est√° em background
    if (ctx.state === SessionState.BACKGROUND) {
      return BACKGROUND_TIMEOUT; // 20min
    }

    // Se est√° em modo leitura
    if (isReadingMode() && ctx.state === SessionState.IDLE) {
      return BACKGROUND_TIMEOUT; // 20min tamb√©m
    }

    // Padr√£o: 10 minutos
    return IDLE_TIMEOUT;

  }, [isReadingMode]);

  const handleExpiry = useCallback(async () => {
    const ctx = sessionManager.getContext();

    console.log('[ACTIVITY] üîí Sess√£o expirada:', {
      state: ctx.state,
      idleMinutes: ctx.idleMinutes,
      route: ctx.currentRoute
    });

    // Se estava em background, verifica servidor primeiro
    if (ctx.state === SessionState.BACKGROUND) {
      const stillValid = await checkServerSession();
      if (stillValid) {
        console.log('[ACTIVITY] ‚úÖ Sess√£o ainda v√°lida no servidor');
        resetTimer();
        return;
      }
    }

    // Limpa dados
    localStorage.removeItem('auth_token');
    localStorage.removeItem('session_token');
    sessionStorage.clear();

    // Notifica servidor
    try {
      await fetch('/api/session/destroy', {
        method: 'POST',
        credentials: 'include'
      });
    } catch (error) {
      console.error('[ACTIVITY] Erro ao destruir sess√£o:', error);
    }

    sessionManager.setState(SessionState.EXPIRED);

    // Toast
    toast({
      title: 'üîí Sess√£o Encerrada',
      description: `Sua sess√£o foi encerrada ap√≥s ${ctx.idleMinutes} minutos de inatividade.`,
      variant: 'destructive'
    });

    setTimeout(() => {
      setLocation('/login?reason=inactivity');
    }, 2000);

  }, [toast, setLocation]);

  const checkServerSession = useCallback(async (): Promise<boolean> => {
    const sessionToken = localStorage.getItem('session_token');
    if (!sessionToken) return false;

    try {
      const response = await fetch('/api/session/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sessionToken }),
        credentials: 'include'
      });

      const data = await response.json();

      if (data.expired) {
        console.log('[ACTIVITY] ‚ùå Servidor: sess√£o expirada');
        return false;
      }

      console.log(`[ACTIVITY] ‚úÖ Servidor: ${data.minutesRemaining}min restantes`);
      return true;

    } catch (error) {
      console.error('[ACTIVITY] Erro ao verificar servidor:', error);
      // Em caso de erro de rede, mant√©m sess√£o (modo offline)
      return true;
    }
  }, []);

  const resetTimer = useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    const timeout = getTimeoutDuration();

    if (timeout === null) {
      console.log('[ACTIVITY] ‚è∏Ô∏è Timer pausado (opera√ß√£o em andamento)');
      return;
    }

    timeoutRef.current = setTimeout(() => {
      handleExpiry();
    }, timeout);

    console.log(`[ACTIVITY] ‚è±Ô∏è Timer resetado: ${timeout / 60000}min`);

  }, [getTimeoutDuration, handleExpiry]);

  const sendHeartbeat = useCallback(async () => {
    const token = localStorage.getItem('auth_token');
    const ctx = sessionManager.getContext();

    // N√£o envia heartbeat se offline ou em background h√° muito tempo
    if (!ctx.isOnline || !ctx.isVisible) {
      return;
    }

    if (!token) return;

    try {
      await fetch('/api/session/heartbeat', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          state: ctx.state,
          route: ctx.currentRoute
        }),
        credentials: 'include'
      });

      console.log('[ACTIVITY] üíì Heartbeat OK');

    } catch (error) {
      // Silencioso - pode estar offline
    }
  }, []);

  useEffect(() => {
    // Eventos de intera√ß√£o ATIVA
    const activeEvents = [
      'click',
      'touchstart',
      'keydown',
      'input',
      'submit'
    ];

    // Eventos de intera√ß√£o PASSIVA
    const passiveEvents = [
      'scroll',
      'mousemove'
    ];

    let scrollTimeout: NodeJS.Timeout;
    let mouseMoveTimeout: NodeJS.Timeout;

    const handleActiveEvent = (e: Event) => {
      sessionManager.recordInteraction(e.type);
      resetTimer();
      sendHeartbeat();
    };

    const handleScroll = () => {
      // S√≥ considera atividade se scrollar de forma significativa
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        sessionManager.recordActivity();
        resetTimer();
      }, 500); // Debounce de 500ms
    };

    const handleMouseMove = () => {
      // Mouse move s√≥ conta se mover bastante (n√£o apenas tremor)
      clearTimeout(mouseMoveTimeout);
      mouseMoveTimeout = setTimeout(() => {
        sessionManager.recordActivity();
        // N√ÉO envia heartbeat para mouse move (muito frequente)
      }, 2000); // Debounce de 2s
    };

    // Registra listeners
    activeEvents.forEach(event => {
      document.addEventListener(event, handleActiveEvent, { passive: true });
    });

    document.addEventListener('scroll', handleScroll, { passive: true });
    document.addEventListener('mousemove', handleMouseMove, { passive: true });

    // Inicia timer
    resetTimer();

    // Verifica√ß√£o peri√≥dica
    checkIntervalRef.current = setInterval(async () => {
      const ctx = sessionManager.getContext();

      // Atualiza minutos idle
      const minutes = Math.floor((Date.now() - ctx.lastActivityAt) / 60000);
      ctx.idleMinutes = minutes;

      // Se passou de 2min sem intera√ß√£o, muda para IDLE
      if (minutes >= 2 && ctx.state === SessionState.ACTIVE) {
        sessionManager.setState(SessionState.IDLE);
      }

      // Se est√° vis√≠vel, verifica servidor
      if (ctx.isVisible && ctx.isOnline) {
        await checkServerSession();
      }

    }, CHECK_INTERVAL);

    // Subscribe para mudan√ßas de estado
    const unsubscribe = sessionManager.subscribe((ctx) => {
      console.log('[SESSION] üìä Estado atualizado:', ctx.state);
    });

    // Cleanup
    return () => {
      activeEvents.forEach(event => {
        document.removeEventListener(event, handleActiveEvent);
      });
      document.removeEventListener('scroll', handleScroll);
      document.removeEventListener('mousemove', handleMouseMove);

      if (timeoutRef.current) clearTimeout(timeoutRef.current);
      if (checkIntervalRef.current) clearInterval(checkIntervalRef.current);
      clearTimeout(scrollTimeout);
      clearTimeout(mouseMoveTimeout);

      unsubscribe();
    };

  }, [resetTimer, sendHeartbeat, checkServerSession]);

  return sessionManager.getContext();
}
```

### 3. Detec√ß√£o de Opera√ß√µes Longas

```typescript
// client/src/hooks/useOperation.tsx (NOVO)

import { useEffect, useCallback } from 'use';
import { sessionManager } from '@/lib/sessionState';

/**
 * Hook para opera√ß√µes longas que n√£o devem expirar a sess√£o
 * Uso: const { startOperation, endOperation } = useOperation();
 */
export function useOperation() {
  const startOperation = useCallback((name: string) => {
    console.log(`[OPERATION] üöÄ Iniciando: ${name}`);
    sessionManager.setActiveOperation(true);
  }, []);

  const endOperation = useCallback((name: string) => {
    console.log(`[OPERATION] ‚úÖ Finalizada: ${name}`);
    sessionManager.setActiveOperation(false);
    sessionManager.recordActivity(); // Reseta timer ap√≥s opera√ß√£o
  }, []);

  return { startOperation, endOperation };
}

// Exemplo de uso:
// const { startOperation, endOperation } = useOperation();
//
// const handleExport = async () => {
//   startOperation('Exportar CSV');
//   try {
//     await exportData();
//   } finally {
//     endOperation('Exportar CSV');
//   }
// };
```

### 4. Sincroniza√ß√£o Entre Abas (BroadcastChannel)

```typescript
// client/src/lib/sessionSync.ts (NOVO)

class SessionSync {
  private channel: BroadcastChannel | null = null;
  private tabId: string;

  constructor() {
    this.tabId = `tab_${Date.now()}_${Math.random()}`;

    if ('BroadcastChannel' in window) {
      this.channel = new BroadcastChannel('mesc_session');
      this.setupListeners();
      console.log('[SYNC] üì° BroadcastChannel ativo:', this.tabId);
    } else {
      console.warn('[SYNC] ‚ö†Ô∏è BroadcastChannel n√£o suportado');
      // Fallback: localStorage events
      this.setupLocalStorageFallback();
    }
  }

  private setupListeners() {
    this.channel?.addEventListener('message', (event) => {
      const { type, data, from } = event.data;

      // Ignora mensagens da pr√≥pria aba
      if (from === this.tabId) return;

      console.log(`[SYNC] üì® Recebido de ${from}:`, type);

      switch (type) {
        case 'activity':
          // Outra aba teve atividade, reseta timer local
          sessionManager.recordActivity();
          break;

        case 'logout':
          // Outra aba fez logout, desloga todas
          this.handleCrossTabLogout();
          break;

        case 'expired':
          // Outra aba expirou, verifica se deve expirar tamb√©m
          this.handleCrossTabExpiry();
          break;
      }
    });
  }

  broadcastActivity() {
    this.channel?.postMessage({
      type: 'activity',
      from: this.tabId,
      timestamp: Date.now()
    });
  }

  broadcastLogout() {
    this.channel?.postMessage({
      type: 'logout',
      from: this.tabId
    });
  }

  broadcastExpiry() {
    this.channel?.postMessage({
      type: 'expired',
      from: this.tabId
    });
  }

  private handleCrossTabLogout() {
    console.log('[SYNC] üö™ Logout em outra aba - deslogando esta tamb√©m');
    localStorage.removeItem('auth_token');
    localStorage.removeItem('session_token');
    window.location.href = '/login?reason=cross_tab_logout';
  }

  private handleCrossTabExpiry() {
    console.log('[SYNC] ‚è∞ Expira√ß√£o em outra aba - verificando servidor');
    // N√£o desloga imediatamente, verifica servidor primeiro
    sessionManager.checkServerSession();
  }

  private setupLocalStorageFallback() {
    // Para browsers antigos sem BroadcastChannel
    window.addEventListener('storage', (e) => {
      if (e.key === 'session_activity' && e.newValue) {
        const data = JSON.parse(e.newValue);
        if (Date.now() - data.timestamp < 1000) {
          sessionManager.recordActivity();
        }
      }
    });
  }
}

export const sessionSync = new SessionSync();
```

---

## üìä MATRIZ DE DECIS√ÉO DE TIMEOUT

| Cen√°rio | Vis√≠vel? | Online? | Rota | Opera√ß√£o? | Timeout |
|---------|----------|---------|------|-----------|---------|
| Uso normal | ‚úÖ Sim | ‚úÖ Sim | Qualquer | ‚ùå N√£o | **10min** |
| Lendo escala | ‚úÖ Sim | ‚úÖ Sim | /schedules | ‚ùå N√£o | **20min** |
| Lendo forma√ß√£o | ‚úÖ Sim | ‚úÖ Sim | /formation | ‚ùå N√£o | **20min** |
| App minimizado | ‚ùå N√£o | ‚úÖ Sim | Qualquer | ‚ùå N√£o | **20min** |
| Exportando CSV | ‚úÖ Sim | ‚úÖ Sim | /reports | ‚úÖ Sim | **‚àû (pausado)** |
| Offline (PWA) | ‚úÖ Sim | ‚ùå N√£o | Qualquer | ‚ùå N√£o | **‚àû (pausado)** |
| M√∫ltiplas abas | ‚úÖ Qualquer | ‚úÖ Sim | Qualquer | ‚ùå N√£o | **Sincronizado** |

---

## üß™ CEN√ÅRIOS DE TESTE

### Teste 1: App em Background (Android)
```
1. Abrir MESC no Chrome (Android)
2. Ver dashboard
3. Apertar bot√£o HOME
4. Aguardar 15 minutos
5. Voltar para o app
ESPERADO: ‚úÖ Ainda logado (timeout 20min para background)
```

### Teste 2: Leitura de Documento
```
1. Abrir /schedules/view (escala de missas)
2. N√£o tocar na tela por 12 minutos
3. Clicar em qualquer lugar
ESPERADO: ‚úÖ Ainda logado (rotas de leitura = 20min)
```

### Teste 3: Exporta√ß√£o Longa
```
1. Abrir /reports
2. Clicar em "Exportar CSV Completo"
3. Aguardar 15 minutos (opera√ß√£o longa simulada)
ESPERADO: ‚úÖ Ainda logado (opera√ß√µes pausam timer)
```

### Teste 4: M√∫ltiplas Abas
```
1. Abrir MESC em aba 1
2. Abrir MESC em aba 2
3. Usar aba 1 ativamente
4. Aguardar 12min sem tocar aba 2
5. Clicar na aba 2
ESPERADO: ‚úÖ Ainda logado (atividade sincronizada)
```

### Teste 5: Offline (PWA)
```
1. Instalar PWA
2. Desativar conex√£o
3. Navegar offline por 20 minutos
4. Reconectar
ESPERADO: ‚úÖ Verifica servidor, renova se v√°lido
```

---

## üéØ CONFIGURA√á√ÉO RECOMENDADA

```typescript
// config/session.ts
export const SESSION_CONFIG = {
  // Timeouts base
  ACTIVE_TIMEOUT: 10 * 60 * 1000,      // 10min uso normal
  BACKGROUND_TIMEOUT: 20 * 60 * 1000,  // 20min em background
  READING_TIMEOUT: 20 * 60 * 1000,     // 20min rotas de leitura

  // Rotas consideradas "leitura" (timeout estendido)
  READING_ROUTES: [
    '/schedules',
    '/schedules/view',
    '/formation',
    '/reports',
    '/ministers/directory'
  ],

  // Eventos de atividade forte (resetam timer imediatamente)
  STRONG_ACTIVITY_EVENTS: [
    'click',
    'touchstart',
    'keydown',
    'input',
    'submit',
    'change'
  ],

  // Eventos de atividade fraca (debounce antes de resetar)
  WEAK_ACTIVITY_EVENTS: [
    { event: 'scroll', debounce: 500 },
    { event: 'mousemove', debounce: 2000 }
  ],

  // Verifica√ß√£o peri√≥dica
  CHECK_INTERVAL: 30 * 1000,  // 30s

  // Heartbeat
  HEARTBEAT_INTERVAL: 60 * 1000,  // 1min (apenas quando ativo)

  // Warning
  WARNING_THRESHOLD: 2 * 60 * 1000  // Aviso com 2min restantes
};
```

---

## ‚úÖ VANTAGENS DESTA ABORDAGEM

1. ‚úÖ **Contexto-Aware** - Sabe quando usu√°rio est√° realmente inativo
2. ‚úÖ **Mobile-Friendly** - Respeita apps em background
3. ‚úÖ **PWA-Compatible** - Funciona offline
4. ‚úÖ **Multi-Tab Sync** - Sincroniza entre abas
5. ‚úÖ **Opera√ß√µes Longas** - Pausa timer durante exports/uploads
6. ‚úÖ **Rotas de Leitura** - Timeout estendido para consulta
7. ‚úÖ **Performance** - Debounce em eventos frequentes
8. ‚úÖ **Graceful Degradation** - Fallbacks para browsers antigos

---

## üìù RESUMO DA RESPOSTA

### O que √© considerado "atividade"?

**ATIVIDADE FORTE (Reseta para 0):**
- ‚úÖ Cliques/Toques
- ‚úÖ Digita√ß√£o
- ‚úÖ Mudan√ßa de p√°gina
- ‚úÖ Submit de formul√°rio
- ‚úÖ Requisi√ß√µes API

**ATIVIDADE FRACA (Reseta com debounce):**
- ‚ö†Ô∏è Scroll (ap√≥s 500ms parado)
- ‚ö†Ô∏è Mouse move (ap√≥s 2s parado)

**N√ÉO √â INATIVIDADE:**
- ‚úÖ App em background (timeout 20min)
- ‚úÖ Lendo conte√∫do est√°tico (timeout 20min)
- ‚úÖ Processando opera√ß√£o longa (pausado)
- ‚úÖ Offline (pausado)
- ‚úÖ Outra aba ativa (sincronizado)

**INATIVIDADE REAL:**
- ‚ùå 10min sem nenhum evento
- ‚ùå 20min em background ininterrupto
- ‚ùå Browser fechado

---

Essa abordagem resolve seus cen√°rios problem√°ticos?
